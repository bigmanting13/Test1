# ==============================
# SOL Process Start Logger (Discord)
# Sends ONLY first-seen processes after script starts (no repeats).
# Press ENTER to stop.
# ==============================

$WebhookURL = "https://discord.com/api/webhooks/1472618505412280581/NN6uESabI44NgZRf4OiKAAZSY9IFbZqsAELEDAa9BjUDmmHn3qHLxf_VskhLR5TH8x9l"
$UserTag = $env:USERNAME

# batching
$Buffer = New-Object System.Collections.Generic.List[string]
$LastSend = Get-Date
$SendEverySeconds = 5
$SendMaxItems = 10

# "seen" set: key = full path if known, otherwise name
$Seen = New-Object 'System.Collections.Generic.HashSet[string]'

function Send-DiscordMessage {
    param([string]$Message)
    $body = @{ content = $Message } | ConvertTo-Json
    try { Invoke-RestMethod -Uri $WebhookURL -Method Post -Body $body -ContentType "application/json" | Out-Null } catch {}
}

function Flush-Batch {
    if ($Buffer.Count -eq 0) { return }
    $msg = "**$UserTag**`nProcess starts (first-seen only):`n" + ($Buffer -join "`n")
    Send-DiscordMessage $msg
    $Buffer.Clear()
    $global:LastSend = Get-Date
}

function Get-SigStatusFast {
    param([string]$Path)
    if (-not $Path -or -not (Test-Path -LiteralPath $Path)) { return "NoPath" }
    try { return (Get-AuthenticodeSignature -FilePath $Path).Status.ToString() } catch { return "SigError" }
}

Send-DiscordMessage "**$UserTag**`nMonitoring started"

$srcId = "SOL.ProcStart"
try { Unregister-Event -SourceIdentifier $srcId -ErrorAction SilentlyContinue } catch {}
Register-WmiEvent -Class Win32_ProcessStartTrace -SourceIdentifier $srcId | Out-Null

Write-Host ""
Write-Host "Monitoring process starts (first-seen only). Press ENTER to stop." -ForegroundColor Green

try {
    while ($true) {
        if ([Console]::KeyAvailable) {
            $k = [Console]::ReadKey($true)
            if ($k.Key -eq "Enter") { break }
        }

        $evt = Wait-Event -SourceIdentifier $srcId -Timeout 0.5
        if (-not $evt) {
            if ((Get-Date) -gt $LastSend.AddSeconds($SendEverySeconds)) { Flush-Batch }
            continue
        }

        $p = $evt.SourceEventArgs.NewEvent
        $time = Get-Date -Format "HH:mm:ss"
        $procId  = [int]$p.ProcessID
        $pprocId = [int]$p.ParentProcessID
        $name = [string]$p.ProcessName

        # Try to resolve path (may be empty for protected/system)
        $path = ""
        try {
            $proc = Get-CimInstance Win32_Process -Filter "ProcessId=$procId"
            if ($proc -and $proc.ExecutablePath) { $path = [string]$proc.ExecutablePath }
        } catch {}

        # Key: prefer full path; otherwise fall back to name
        $key = if ($path) { $path.ToLowerInvariant() } else { ("name:" + $name.ToLowerInvariant()) }

        # ONLY first time we see this key during this run
        if (-not $Seen.Add($key)) {
            Remove-Event -EventIdentifier $evt.EventIdentifier -ErrorAction SilentlyContinue
            continue
        }

        $sig = Get-SigStatusFast -Path $path
        $pstr = if ($path) { $path } else { "<no path>" }

        $entry = "[$time] $name (PID:$procId PPID:$pprocId) | Sig:$sig | $pstr"
        $Buffer.Add($entry) | Out-Null

        if ($Buffer.Count -ge $SendMaxItems) { Flush-Batch }

        Remove-Event -EventIdentifier $evt.EventIdentifier -ErrorAction SilentlyContinue
    }
}
finally {
    Flush-Batch
    try { Unregister-Event -SourceIdentifier $srcId -ErrorAction SilentlyContinue } catch {}
    try { Remove-Event -SourceIdentifier $srcId -ErrorAction SilentlyContinue } catch {}
    Send-DiscordMessage "**$UserTag**`nMonitoring ended"
}
